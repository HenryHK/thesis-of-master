\title{Secure wallet for an unforkable blockchain}
%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{float}
\usepackage{csquotes}
\usepackage{pdfpages}
\usepackage{caption}

\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE The University of Sydney}\\[1.5cm] % Name of your university/college
\textsc{\Large School of Information Technology}\\[0.5cm] % Major heading such as course name
\textsc{\large Thesis of Master of IT}\\[0.5cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.6cm]
{ \huge \bfseries Secure Wallet For An Unforkable Blockchain}\\[0.4cm] % Title of your document
\HRule \\[1.6cm]
 
%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Author:}\\
Lin \textsc{Han} % Your name
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Supervisor:} \\
Dr. Vincent \textsc{Gramoli} % Supervisor's Name
\end{flushright}
\end{minipage}\\[2cm]

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[2cm] % Date, change the \today to a set date if you want to be precise

%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics{logo.png}\\[1cm] % Include a department/university logo - this will require the graphicx package
 
%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}

\newpage
\vfil
\hfil \textit{Special thanks to Dr. Vincent Gramoli and everyone in CSRG of the University of Sydney who provides generous help during my research} \hfil
\vfil
\newpage

\tableofcontents
\vfill

\newpage

% \begin{abstract}
% Your abstract.
% \end{abstract}

\section{Introduction}

% context part, introduction to cryptocurrencies
From the time when Block 0 of Bitcoin blockchain, the Genesis Block, is created at 18:15:05 GMT on January 3rd, 2009, the words ``cryptocurrencies'' and ``Blockchain'' become one of the most popular topics in information technology fields. The ``decentralized'' and ``anonymous'' nature of cryptocurrencies overcomes the weakness of traditional \textit{trust-based} electronic payments who relies heavily on trusted third-party financial institutions. Its cryptography-based nature also ensures its security in some sense. The \textit{cryptographic proof-of-work} of bitcoin enables reliable transaction between two parties directly\cite{nakamoto2008bitcoin}. Through almost 10 years development, cryptocurrencies turns out to be a large family and can be accessed via desktop, laptop, or even mobile devices like smart phones.

% Problem
Though bitcoin gives a practical solution on traditional \textit{double spending} problem in digital currencies, this doesn't mean that it is secure in all aspects. One possible issue is bitcoin blockchain's forkable feature. Actually, other cryptocurrencies allowing forkable chains all suffer from the very same issue. It will become a problem for wallet users if the nodes they are contacting is hijacked. In this sense, unforkable blockchain is proven to overcome this shortcommings\cite{DBLP:journals/corr/CrainGLR17}. To consider in another aspect, another possible solution to secure transaction is to adopt mechanism like \textit{zero knowledge contingent payment} which are released if and only if some knowledge is disclosed by the payee and to do this in a trustless manner where neither the payer or payee can cheat\cite{wiki2011zero}\cite{sasson2014zerocash}. Whilst there are several theoretical discussion and practices in a variety of contexts, this paper will concentrate on how to develop a secure cryptocurrency wallet on the basis of unforkable blockchain and enable secure trades between parties by the help of zero knowledge contingent payments. 

% Contributions
In this project, I intend to contribute in two separated directions: one is to develop a secure mobile client for Red Belly Blockchain - a practice to deploy unforkable blockchain onto modern mobile devices; the other is to explore the way to enable zero knowledge contingent payments within Red Belly Blockchain network. The primary goal of this research is to examine the feasibility of real-life secure application for unforkable blockchain like Red Belly Blockchain.

% Roadmap
In the following report, related works will be given first. Essential concepts and problems will be addressed in this part. After the literature review, the methodologies and proposed contribution is given. After that, detailed report on implementation of secure wallet and zero knowledge contingent payments will be shown. Last but not the least, current outcomes of this project will be discussed. And finally, a conclusion as well as possible improvements and future works will conclude this paper.

% Literature review part
%   this content is comming from assignment 2 Literature review
\section{Literature Review}
\label{sec:Literature Review}

\subsection{Bitcoin}

Bitcoin is the first decentralized digital currency as well as a digital payment system. The whole system is peer-to-peer based, whose transactions are between users directly without participation of intermediary. Transactions are verified by network nodes - known as \textit{mining} - and recorded in a public distributed ledger called \textit{blockchain}.

\subsubsection{Blockchain}

Blockchain is the way how Bitcoin keeps its public ledger within its peer-to-peer network. To some extent, blockchain is a peer-to-peer distributed timestamp server. The ultimate goal of this design is to solve \textit{double-spending} problems and prevent modification of transaction records\cite{nakamoto2008bitcoin}. 

Each full node in the Bitcoin network keeps a full copy of the blockchain, in which all blocks validated by this particular is stored. When several nodes within the network independently arrive at identical blockchains, they are considered to be in \textit{consensus}. As its name suggests, a blockchain is a digital chain of blocks, where a timestamp, a nonce, and a Merkle Tree is stored.  The blocks are chained cryptographically using hash. In detail, each block contains the hash of its previous block ,finally leading to the Genesis Block. Any modification on blocks in the chain would violates all subsequent hashes, which is vital for consistency of the ledger. Figure \ref{fig:blockchain} shows part of a blockchain. 

% blockchain figure here
\newpage
\begin{figure}
    \centering
    \includegraphics[scale=0.9]{blockchain.png}
    \caption{Blockchain from \textit{https://steemit.com/bitcoin/@cryptovest/bitcoin-and-blockchain-what-math-puzzle-do-miners-actually-solve}}
    \label{fig:blockchain}
\end{figure}

However, computing a hash is expensive. This truth enables \textit{proof-of-work} in bitcoin network. 

\subsubsection{Proof of Work}

According to blockchains' feature, a huge amount of computation is required in the generation of each block. Meanwhile, there is a \textit{proof-of-work} mechanism to make the distributed timestamp server work and determine representation in majority decision making. Especially, when there are multiple chains (forks), consensus rules will pick up the longest chain, which contains the most proof of work during its generation\cite{nakamoto2008bitcoin}.

In this way, any malicious changes on previous blocks would violate its following blocks. That is to say, hacker with huge computing power can hijack the blockchain if he can generate the longest chain from the block he hacks. In turn, he has to own more than half of the computing power within the whole blockchain network\cite{NG17}.

\subsubsection{Contracts}

There are distributed contracts in Bitcoin transactions for agreement enforcement, which provides another way to formalize and guarantee agreements rather than traditional court system. Examples include Escrow, Micropayment channels and CoinJoin.

Some of the contracts can be implemented in Bitcoin Script, especially the zero knowledge contingent payments in Bitcoin is achieved with support of bitcoin scripts. However the Red Belly Blockchain doesn't have a robust scripting language like Bitcoin does.

\subsection{Ethereum}

\subsubsection{Previous Work of Bitcoin}

Bitcoin provides a protocol allowing weak implementation of \textit{smart contracts}. However, several limitations exists in Bitcoin's scripting language:

\begin{enumerate}
    \item \textbf{Not Turing-Completeness} - Bitcoin scripts lacks loops.
    \item \textbf{Lack of States} - UTXOs scripts is only for one-off contracts.
    \item \textbf{Blindness of Blockchain} - Bitcoin scripts cannot access blockchain data.
    \item \textbf{Blindness of Value} - Bitcoin either consumes the entire UTXO or none of it
\end{enumerate}

\subsubsection{Rationale}

Ethereum implements a blockchain with Turing-complete scripts, states, value awareness and blockchain awareness, which enables development of smart contracts, and even new protocols\cite{wood2014ethereum}.

\subsection{Balance Attack}
\label{sec:Balance Attack}

As the previous review mentioning, to attack a blockchain, or specifically to rewrite the content of a block, the hacker should have more than half of the computing power of the whole blockchain network which is almost unfeasible in real world. In particular, by delaying the propagation of blocks in Bitcoin system, the hacker can in result delay the growth of the longest branch of the system. In other word, he can then hijack the blockchain even without a large amount of computing power. Ethereums' ``Blockchain 2.0'' somehow fixes this problem, but there is still other possible method against forked blockchain. One practice is the \textbf{Balance Attack} \cite{Gra16}\cite{NG17}\cite{NG16}against \textit{proof-of-work} blockchain systems.

To achieve a balance attack within the blockchain network, the attacker should divide the network into subgroups of similar mining power by cutting off their communications. During this down time, the attacker issues transaction in the \textit{transaction group}, and mine blocks in the \textit{block group} simultaneously. This action only ends when it comes to the point where the tree of the block subgroup outweighs the tree of the transaction group, which is with high possibility. The balance, in result, can leverage the \textit{GHOST} protocol that accounts for sibling or uncle blocks to determine on a chain of blocks. This strategy allows the attacker to mine a branch regardless of the rest of the network so that he can influence the branch determination process while merging\cite{NG17}. The process is as shown in Figure \ref{fig:balance_attack}.

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{balance_attack.png}
    \caption{Balance Attack}
    \label{fig:balance_attack}
\end{figure}

\subsection{Unforkable Blockchain}
\label{sec:Unforkable Blockchain}

\subsubsection{Byzantine Consensus Problem}

The \textit{Byzantine Consensus Problem} refers to the \textit{Byzantine General's Problem} proposed by Leslie Lamport, Robert Shostak and Marshall Pease in 1982. The problem is complicated by the presence of traitorous generals who may not only cast a vote for a suboptimal strategy, they may do so selectively. All the votes and results are simplified to attack or retreat. The problem is complicated further by the generals being physically separated and having to send their votes via messengers who may fail to deliver votes or may forge false votes\cite{lamport1982byzantine}.

In computer science area, typically computers or participants in network are mapped to generals and links between them are mapped to messengers.

\subsubsection{Traditional Blockchain Byzantine Consensus Problem}

The \textit{proof-of-work} of Bitcoin blockchain is the primary solution to \textit{Byzantine Consensus Problem}. 

In detail, a model of Bitcoin network can be built upon the classic Byzantine Consensus Problem. The distributed system is the alliance of generals, in which the upper bounds on the delay of communicating and decision-making is unknown. 

However, regarding to our previous discussion on \textit{Balance Attack}, attackers can still disrupt the consensus system to beat the Bitcoin Byzantine Consensus\cite{gramoli2017blockchain}. Because there is no guarantee that the decided value is proposed by a valid process.

\subsubsection{Democratic Byzantine Consensus}

Democratic Byzantine Fault Tolerance is a system specially tailored for consortium blockchains based on \textit{Binary Byzantine Consensus}. In \textit{Binary Byzantine Consensus}\cite{mostefaoui2015signature}, each trusted participant issue proposal with either 0 or 1 and decides that the final agreement such that:

\begin{enumerate}
    \item No pair of trusted participants have different decision.
    \item Every trusted participant decides
    \item If all correct participant propose the the same value, then no other value can be deiced
\end{enumerate}

In safe Democratic Byzantine Fault Tolerance\cite{DBLP:journals/corr/CrainGLR17}, a mechanism called binary broadcast for binary Byzantine Consensus system is adopted. To conclude, there are four aspects that is strictly followed within DBFT:

\begin{enumerate}
    \item \textbf{Binary Value Obligation} - if t+1 correct BV-broadcast $v$, then $v$ is eventually added to the set binary values of all correct process.
    \item \textbf{Binary Value Justification} - if $p_i$ is correct and and $v$ in $binary-values_i$ then $v$ was broadcasted by a correct process.
    \item \textbf{Binary Value Uniformity} - if $v$ is added to $binary-value_i$ of correct $p_i$, then eventually $v$ will be in $binary-value_j$ for all correct $p_j$.
    \item \textbf{Binary Value Termination} - eventually $binary-value$ of correct $p_i$ is not empty. 
\end{enumerate}

\subsection{The Red Belly Blockchain}

Red Belly Blockchain is new blockchain relying on the Democratic BFT. The \textit{Genesis Block} of this blockchain contains the initial information as well as a list of n participants. All accesses of external nodes requires these participants as the middleware. In this case, a transaction is regarded as committed if $t+1$ participating nodes agreed so it can be written into next block.

The performance of this new blockchain is quite good. It can achieve more than 400 transactions per second and with great scalability up to 90 server nodes.

\subsection{Zero Knowledge Contingent Payment}
\label{sec:Zero Knowledge Contingent Payment}

\subsubsection{Bitcoin ZKCP}

Zero Knowledge Contingent Payment in Bitcoin is first proposed by Gregory Maxwell in 2011 on Bitcoin Wiki\cite{maxwell5zero}. The basic process can be illustrated by an example\cite{campanelli2017zero}:

\begin{displayquote}
    Alice is a fan of Sudoku puzzle. However, there is a puzzle that she is trying days but in vain. She gives up and broadcasts a message within a fan group proclaiming that ``I will pay whoever solves this puzzle.'' Bob see the broadcast, solves it, and want to sell the result to Alice. The problem is either Alice or Bob is willing to be the first person to give out what they have.

    To solve this dilemma, Alice and Bob goes for a Bitcoin, which allows one to issue a transaction and also specify the conditions to be met in order to claim the transaction. In this case, Alice propose a payment transaction to blockchain that includes encoded Sudoku puzzle and the rules. Whoever solves the puzzle is able to get the fund.

    Using the Bitcoin ZKCP protocol, Bob knows a solution $s$ and encrypts the solution using a key $k$ such that $Enc_k(s)=c$ and he computes $y$ such that $SHA256(k)=y$. He then send the key $k$ and $c$ to Alice together with a zero knowledge proof that $c$ is an encryption of $s$ under the key $k$ and  that $SHA256(k)=y$. Once Alice has verified the proof, she creates a transaction to the blockchain that pays Bob $n$ bitcoins, and says that Bob can only claim the coins if he provides the value $k'$ such that $SHA256(k')=y$. Bob then published $k$ and claims the fund. In this way, Alice learns $k$ can decrypt c so that she knows the solution $s$
\end{displayquote}

Specifically in Blockchain, the ZKCP protocol now has several practices rather than theory. One is ZK-SNARK protocols allowing for the practical implementation of the necessary proofs\cite{kalai2006succinct}\cite{ben2015secure}\cite{ecc2011}.

\subsubsection{Zero Knowledge Contingent Payment without Scripts}

However, all implemented ZKCP protocols now are based on scripting language in traditional forkable blockchain\cite{Banasik2016}. Besides, there is no convincing data of its performance on modern mobile devices\cite{doi:10.1080/00207160.2014.933816}.

\section{Motivation}

From the above review of cryptocurrencies and blockchain contexts, one can conclude that the blockchain technology adopted by cryptocurrencies nowadays has potential risks regarding to its forkable nature. This also influence the usage of current cryptocurrency wallet - there is no guarantee that the proposed transaction (or retrieved balance) from wallet is securely handled by the server if it contacts only one single machine.

Hence, the motivation of this research comes from this gap. The aim of this research is to develop a wallet making both transaction proposing and balance retrieving reliable and correct. During the first part of this research, a secure wallet will be developed, performing in a Red Belly Blockchain way to avoid possible attacks targeting at fork chains. The Zero Knowledge Contingent Proof will try to add another guarantee so that either party within a transaction cannot cheat for its own benefits.

\section{Methodologies and Proposed Contributions}

\subsection{Previous Work}

\subsubsection{Red Belly Blockchain}

This research is on the basis of Red Belly Blockchain which is an unforkable blockchain running \textit{Democratic Byzantine Fault Tolerance}. The development of secure wallet is build upon the implementation of Red Belly Blockchain.

In Red Belly Blockchain, all nodes are communicated through TCP+SSL. Nodes in this blockchain consists of nodes running Byzantine Consensus Algorithms - the \textit{participants}, and external nodes communicating with the \textit{participants}. A transaction or balance of an account can only be considered correct if more than one thirds of the \textit{participants} agreed as required by DBFT.


\subsection{Proposed Contributions}

To develop a secure wallet, a secure protocol between server and clients is required. In this project, TCP and SSL is chosen to be the techniques for communications. I intent to implement \textit{remote procedure call} for Red Belly Blockchain nodes first so that further functions can be achieved on client side. 

Regarding to the client, I intend to implement secure wallet basic balance and transaction request functions complying with the same DBFT algorithm as Red Belly Blockchain nodes. In this sense, users of wallet can ensure that the balance and transaction are correctly obtained or proposed respectively.

In addition to server enhancement and secure wallet development, the pursuit of security also motivated this research to develop a Zero Knowledge Contingent Payments model for RBBC so that no party can cheats within such a `contract'. The ZKCP implementation in RBBC is not like the one in Bitcoin who has scripts supporting this function while RBBC doesn't have.

\subsection{Methodologies}

The ultimate goal of this research is to develop a wallet that enables secure balance retrieving, transaction proposing, as well as trading. This would require design and development in both server side and client side.

The first part of this project is to add secure \textit{remote procedure call} to Red Belly Blockchain. The \textit{RPC} protocol should be through TCP and SSL. Once the \textit{RPC} server is ready, Java and Android client could be developed based on it. After the client is developed, benchmarks on speed of balance retrieving and transaction proposing is required. And at the end of the above, I'll explore to develop a model to integrate \textit{Zero Knowledge Contingent Payments} into the application. 

\section{Secure Wallet}

In this report, secure wallet refers to two parts: the Red Belly Blockchain wallet and the Zero Knowledge Contingent Payments Model. This paper will explain the design and implementation of secure wallet in detail respectively.

\subsection{Red Belly Blockchain Wallet}

\subsubsection{Preliminaries}
\label{sec:preliminaries}

\textbf{Definitions\\}

\textbf{UTXO} - the term \textbf{UTXO} stands for \textit{Unspent Transaction Outputs}. UTXOs in Red Belly Blockchain act as the same role of it in Bitcoin, which records where spendable coins are in blockchain. To store UTXOs in Red Belly Blockchain, a table structure called \text{UTXO table} is used.

\begin{enumerate}
    \item \textit{UtxoOutput} In Red Belly Blockchain, one \textit{unspent transaction output} consists of four fields: \textit{spent} marks whether this output is consumed, \textit{value} shows the amount of coin contained in this output, \textit{address} showing where this output is sent to, and \textit{script} shows the payee's public key, in other word, where this output comes from.

    \item \textit{UTXO Table} The UTXO table is the way Red Belly Blockchain nodes store UTXOs. As figure\ref{fig:utxo_table} shows, the structure to store UTXOs includes two parts: a map structure mapping hash of transaction to list of outputs and another map mapping account address to its related transaction's hash.
\end{enumerate}

UTXOs in Red Belly Blockchain will be serialized into bytes during communication.
\\

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{utxo_table.png}
    \caption{UTXO Table Structure from \textit{Red Belly Blockchain Wiki}}
    \label{fig:utxo_table}
\end{figure}

\textbf{Transaction} - transaction in Red Belly Blockchain is similar with transaction in Bitcoin. To define a transaction in Red Belly Blockchain, we have to define two definitions - the \textit{Transaction Input} and the \textit{Transaction Output}.

\begin{enumerate}
       \item \textit{Transaction Input} stands for the users' `balance' for transaction. It consists of hash of transaction to be redeemed, index of its entry in UTXO table, and script standing for the account address that owns this UTXO.
       \item \textit{Transaction Output} serves as the transfer of coin. It contains the number of coins, the receiver's account address, and the payer's public key as its script. The output will give the money to the address specified. Meanwhile, an entry in UTXO table will be created to this output which makes sure that these coins can be used for another transaction.
\end{enumerate}

In addition to lists of \textit{Transaction Input}s and \textit{Transaction Output}s, the address that the transaction is from as well the hash of the other parts of transaction is included.\\

\textbf{Description of Red Belly Blockchain Transaction Syntax}

First of all, users in Red Belly Blockchain is identified by their public keys ${pk_1}$ generated from ECDSA signature scheme. The address of one specific account is derived from public key using \textit{Hash160}. In the simplest case, transaction $T$ sends some number of coins from an address ${address_1}$ to another address ${address_2}$. The amount of coin is the \textit{value} in \textit{transaction}. The transaction $T$ must have a pointer to a previous transaction $T'$ such that $T$ is valid only if $T'$ is not redeemed before and has enough balance. Hence, in the simplest model, a transaction contains a following tuple $[T] := (TransactionInput: T', TransactOutput: T'', FromAddress: {address_1}, Hash: h([T] except for hash))$. To make a transaction valid, the same private key ${sk_1}$ corresponding to ${pk_1}$ should be used to sign it.

A transaction may also have multiple inputs and outputs which redeems a combination of several previous outputs and produce new outputs to multiple addresses. In Bitcoin network, the total value of one transaction's inputs can be larger than it outputs where the difference is called `transaction fee' for rewarding miners. But we don't have such mechanism in Red Belly Blockchain, we simply conclude that there is no transaction fee or the fee equals to zero in our case.

Another kind of transaction is called \textit{multisig} transaction. We will not consider this in the implementation of basic secure wallet. The concept and usage of it will be introduced in the ZKCP part of this paper.

\subsubsection{Functions of Red Belly Blockchain Wallet}

Just as its name suggests, the wallet application should have a basic function as a real wallet, namely to put money in, get the money and transfer it for goods. While this research is developing a digital one, the following functions is required to be included in the application:

\begin{enumerate}
   \item \textbf{Configurations} - The wallet should be able to be configured according to various usage circumstances. Basically, the node addresses or DNS server addresses that the application communicates with should be able to configured within the application. In addition to this, the security level of application is also set to be configurable. In detail, the number of identical responses to accept as the correct response and the choice whether using an encryption during communication. The aim of the later one is to give users the right to choose from security or speed because possible latency may occur if there are more server to communicate or more complex encryption to compute.

   \item \textbf{Account Settings} - As mentioned in section \ref{sec:preliminaries}, an account is represented by its public key or derived addresses. The public key and secret key pair is generated from ECDSA signature scheme. The application should be able to create new key pair or import existing key pair (indeed only private key needed to reconstruct).
    
   \item \textbf{Retrieve Balance} - Balance is how many coins are available in UTXOs associated to this account. To get the balance of one specific account, we have two choice to implement, one is to compute the balance on server and return it to client, the other is to return UTXOs to client and let client traverse UTXOs itself. Here the second option is chosen considering that local UTXOs are also needed to propose transaction which gives enough reason to carry this time-consuming procedure. As for security concern, the UTXOs retrieved from Red Belly Blockchain nodes can only be considered correct if adequate number of identical responses - more than one thirds of the \textit{participants} - had been received. Once the client get adequate confirmation of correct UTXOs, it will traverse the UTXOs to get its balance from unspent outputs.

   \item \textbf{Propose Transaction} - The process to propose transaction has one more step compared to the process of balance retrieving. The prerequisite of make a transaction is to get correct UTXOs. Hence, the client will need to get adequate number of identical UTXOs first. After that, the client will existing outputs as the inputs of the newly created transaction, and create corresponding transaction outputs. After the above work is done, the client will wrap transaction inputs, transaction outputs, its own address and the hash of these fields together. The client then will sign the aggregated transaction and propose it to the \textit{participants}. Once more than one thirds of nodes confirmed, the transaction could be regarded as accepted.

   Certainly there should be a way to give the target address for a transaction in the wallet. In our implementation, we use \textit{Base64} encoded string of address bytes to represent an address. The application should be able to decode the address string. Despite of this, a more convenient way through \textit{QR code} is provided. The wallet will be able to display QR code of its account address and scan others' QR code to decode addresses. 

   \item \textbf{Secure Storage} - The way to store information and data of secure wallet is another security concern. Though the consensus system Red Belly Blockchain runs can tolerate malicious node, it's still dangerous to users' privacy. Hence, the application will not store any data into any format of files. Instead, we use the encrypted storage of Android OS. In this way, a system level security storage can be guaranteed.
\end{enumerate}

\subsubsection{Compatibility and External Libraries of Secure Wallet}

To maximum the reusability and reduce the development cost, several existing libraries can be used in the implementation of Red Belly Blockchain secure wallet.

\textbf{BitcoinJ} - BitcoinJ is a Java library working in Bitcoin protocol originally. Thanks to the similar design of Red Belly Blockchain and Bitcoin, our secure wallet reuse the ECDSA signature scheme's implementation in BitcoinJ. In addition, the BitcoinJ library provides plenty of encoding and decoding methods for easily make account information readable.

\textbf{Bounty Castle} - Bounty Castle is a lightweight cryptography library for Java and C#. Because of the lack of reconstruction from private key and customizable signature methods in BitcoinJ, this project introduce Bounty Castle for key pair generation and message signature. 

\textbf{ZXing} - ZXing is a famous open-source library for multi-format 1D/2D barcode image processing written in Java. Secure wallet uses ZXing Android library to produce QR code, scan and decode it. Most recent Android models should be compatible with this library.

\textbf{GSON} - GSON is a Java library used to convert Java Objects into JSON representation and vice versa. The format of RPC calls between Red Belly Blockchain server and client is in JSON array string. We choose GSON for best conversion performance and reliability.

\subsubsection{Implementation of Red Belly Blockchain Wallet}

During this research, all development are carried on on Android Studio 2.3.3 and Android 3.0.0. The wallet follows the pure material design proposed by Android at the maximum extend.

When user enters the application, the default interface would be wallet activity where the balance of wallet will be displayed to illustrate the most basic function of a wallet function. If there is no account and server addresses set previously, the user may configure settings first through the left-side drawer. As for account, user can either choose to import a existing private key and let the application reconstruct the original pair or generate a new key pair randomly. By whichever means, the keys will be stored securely in local storage.

To make a transaction, users can click the account to enter the balance activity where there is history of transactions and a button entry to pay someone. User can choose to type target address string in or scan QR code. If the user wish to receive money, he can also display his address representation in QR code. One may need to refresh so that the updated UTXOs is securely received.

While the user interface goes as the description, most of network communications, encryption, and encoding/decoding works in separate threads to ensure that no data modification or congestion will occur during the use of wallet. A simple Red Belly Blockchain server-client system model can been seen in Figure\ref{fig:server_client}. As the figure shows, clients communicate with multiple \textit{participants} in Red Belly Blockchain in order to get adequate number of identical confirmations. All these communications are issued as an AsyncTask in Android which will not block or affect any operations in UI thread. The same AsyncTask is performed under both wallet activity and balance activity to send a request to get UTXOs for account of the wallet through RPC protocol. If enough number of identical UTXOs are received, the application will traverse them to calculate balance or aggregate usable outputs to propose a transaction. The same procedure is carried on for transaction while the client is only waiting  for an acceptance confirmation rather than UTXOs, which is another RPC function definitely.

In this case, we can ensure that our wallet works securely even when there exist no more than one thirds of malicious participants in the network according to Red Belly Blockchain's DBFT algorithm. Also, thread safety and storage security in our implementation prevent possible violation during application execution.

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{server_client.png}
    \caption{RBBC Server-Client System Model}
    \label{fig:server_client}
\end{figure}

\subsubsection{Benchmark on RBBC Wallet}

Four servers on Amazon Web Service in Oregon are set up for testing purpose. Each of them runs a dummy server. The time elapsed for retrieving balance and proposing transaction is recorded to demonstrate the speed performance of the RBBC secure wallet. The number of server client talks with is controlled by the security level within application settings. All other settings are set as default. And all transactions are between two pre-configured account which is created along with genesis block. The result can be seen in Figure\ref{fig:benchmark}.

\begin{figure}
   \includegraphics[scale=0.8]{benchmark.png}
   \caption{RBBC Secure Wallet Benchmark on Speed}
   \label{fig:benchmark} 
\end{figure}

\subsection{Zero Knowledge Contingent Payments}

The first Zero Knowledge Contingent Payments of Bitcoin is successfully made in 2016. The initial motivation of this exploration is to prove the robustness and capability of Bitcoin Scripts. Things are different in Red Belly Blockchain who has no scripts. Hence, this paper aims to find a proper model to fit \textit{Zero Knowledge Contingent Payments} into Red Belly Blockchain, as well as the implementation of secure wallet.

\subsubsection{Preliminaries}
\label{sec:zkcp_preliminaries}

\textbf{Definitions\\}

\textbf{Secret-Shared ECDSA Secret Key}

Supposing there are two parties, namely buyer and seller, under our scenario, they fix an elliptic curve over $(\mathbb{G},O,g,+)$ over a field ${\mathbb{Z}_p}$. According to scheme of ECDSA, the secret key is a private integer $d\in{\mathbb{Z}_{\mid G \mid}}$. In our case, both buyer and seller input a security parameter and they both know the public key $pk = d \cdot g$ where $d$ is the secret. Besides, the Seller and Buyer know ${d_B}, {d_S} \in {\mathbb{Z}_{\mid G \mid}}$ where ${d_S} \cdot {d_B} = d (mod {\mid G \mid})$. \cite{goldfeder2015securing} \cite{herzberg1997method} The share protocol uses a commitment scheme in which seller make a commit $Commit({D_S})$ in exchange for buyer's secret key. If buyer's key is correct, seller will open his commitment afterwards. \\

\textbf{Paillier Cryptosystem}

Paillier cryptosystem is a probabilistic asymmetric algorithm for public key cryptography. The notable feature of Paillier cryptosystem is its homomorphic property along with its non-deterministic encryption. In this sense, giving only public key $pk$ and the encryption of messages ${m_1}$ and ${m_2}$, one can compute the encryption of ${m_1}+{m_2}$\cite{paillier1999public}. This scheme will be used in Section \ref{sec:usg}\\

\textbf{Time-Locked Commitment}

Zero Knowledge Contingent Payments in Red Belly Blockchain relies on Time-Locked Commitment schemes. To describe informally, the \textit{Time-Locked Commitment} is no more than a standard $(Commit, Open)$ protocol except that it introduce a \textit{force opening} mechanism where the receiver can open the commitment consuming a significant computational time. Though the time to \textit{force open} a commitment differs from receivers, especially when taking mobile devices into accounts, we assume that this difference limited due to real-life efficiency.

\textbf{Cut-and-Choose}

\textit{Cut-and Choose} is a common technique used in zero knowledge proof. The barebone idea of this is to perform multiple times of independent executions of a protocol. Statistically, if the seller can show parts of his answers are correct by uncovering those commitments, there is a high significant probability that the remaining ones are correct as well\cite{lindell2016fast}. 

\subsubsection{Secret-Shared Key Generation Protocol}
\label{sec:kgen}

In the first step of our ZKCP model, buyer and seller establish a connection between each other using the Secret-Share ECDSA scheme described in Section \ref{sec:zkcp_preliminaries}. 

The basic flow works like Figure \ref{fig:secret_share}.

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{secret_share.png}
    \caption{secret-shared key generation from \cite{Banasik2016}}
    \label{fig:secret_share}
\end{figure}

\subsubsection{Unique Signature Generation Protocol}
\label{sec:usg}

The Unique Signature Generation Protocol uses protocol that generates secret-shared key stated in above Section \ref{sec:kgen}. Before the execution of Unique Signature Generation Protocol, we assumes that two parties run the \textit{secret-shared key generation protocol} $a$ times.

Using the results from previous protocol, buyer and seller could sign a message $m$ using the private key. At the first step of Unique Signature Generation Protocol, they jointly create a signing randomness $R$. Then the seller creates a new key using Paillier cryptosystem and sends the encrypted ${d_S}$ (the secret share of seller regarding to secret key $d$) to buyer. Buyer will continue to calculate the remaining part of the encryption of the unfinished signature and return the result to seller. At this stage, the seller is able to decrypts it and finally complete the signature $\sigma$. To ensure the trade remains unharmful if the seller is malicious, same commitment technique is applied here as well. Seller need to make a commitment $Commit({\sigma})$ of his signature $\sigma$ and a time-locked commitment of his secret-shared secret key ${d_S}$ so that buyer can \textit{force open} the commitment if the time of contract expired. 

\subsubsection{SellWitness Protocol}

To construct the final protocol to sell a witness as its name suggests, buyer need to create two transaction - ${T_1}$ and ${T_2}$. In our case, ${T_1}$ contains the money that buyer needs to pay and this will output to the address of the secret-shared key address or to a multisig escrow `t out of 2t-1' using the generated public key $t$ times and his own public key $t-1$ times. However, buyer will not reveal this until he is convinced by the seller. ${T_2}$ is a transaction redeeming ${T_1}$ to seller because the hash of ${T_1}$ can be known without really broadcasting it). The content of transaction ${T_2}$, named as $m$, is the message that needs to be signed later.

To simplify the description, this paper assumes $t=1$ here. At current stage, ${T_2}$ is commonly known to both parties but seller needs ${T_1}$ to spend ${T_2}$ while ${T_1}$ is private to buyer. Meanwhile buyer need learns the signature $\sigma$ of ${T_2}$ so that he can know the secret key that seller committed. Or after some time, the buyer may \textit{force open} seller's $Commit({d_S})$.

Here the \textit{cut-and-choose} will be used again. Supposing there exist a zero knowledge proof of knowledge $\mathcolon{F}$ such that it has a function to extract witness satisfying ${Extract_F}(Buyer, {Challenge_1}, {Answer_1}, {Challenge_2}, {Answer_2}) = x$ and $f(x) = true$ if only answers are all correct and challenges are not the same. 

Buyer will create multiple challenge pairs, ${({c_1}, {c_2})_i}$ respectively. And Seller calculates responses to each of them and commit the result encryption ${r_1}$ and ${r_2}$ using his asymmetric cyphers (the same secret keys used to sign ${T_2}$). Then Buyer selects certain number of challenge pairs and challenge Seller using a random one within each pair. The seller opens the corresponding commitments of secret key in return. Once buyer verifies all these commitments without error. The seller will open all commitments of encrypted answers to Buyerâ€™s challenges. To be noticed, the commitment of secret key of seller is not revealed yet.

Now the buyer will broadcast the private transaction ${T_1}$. The Seller can only spend it by revealing signature of ${T_2}$ so that he can propose ${T_2}$ to be accepted. In this stage, buyer can finally derive the secret key created during the construction of secret-shared key pair. Using this key, buyer then can use any pair of responses to decrypt the correct answer and work out the witness as the return of this trade.


\section{Discussion}

This research receives constructive results from the development of secure wallet and several inspired thoughts from the scratch of the zero knowledge contingent payments model in Red Belly Blockchain. This section will have a discussion on both side in the following contents.

\subsection{Red Belly Blockchain Secure Wallet}

To evaluate the results gained from secure wallet, it's more proper to have a look into its \textbf{performance} and \textbf{security} aspects separately.

\subsubsection{Performance of Secure Wallet}

Definitely, the number of test samples is not adequate right now due to time issues. We can still conclude that the speed of transaction which indeed the time to derive a commonly agreed UTXOs is satisfying considering that the client is communicating with multiple remote servers across ocean. This proves the feasibility to deploy Red Belly Blockchain into real life applications, not limited to application like wallet. 

To be noticed, \textbf{scalability} is another advantage shown in our results. Due to the `independent threads' implementation of secure wallet, the number of \textit{participants} we are communicating with has few influence on the time elapsed to retrieve a correct response.

However, one potential threats that is not taken into consideration in our case is the size of UTXOs. The number clients limits the size growth in our network which leads to uncertain results if we have a large and busy blockchain network. Also the time needed to traverse a local UTXOs storage may also increase as well. The performance of SQLite in Android is not measured as well.

\subsubsection{Security of Secure Wallet}

As for security concern, this research mainly concentrates on communications and local storage. The benefits and tradeoffs of communicating with multiple \textit{participants} are both obvious. As long as the wallet follows principles, UTXOs obtained can be regarded as correct. Potential risks comes from Android local storage. The implementation of secure wallet avoids to leave possibility for any modification in local storage, but there is no guarantee that permission is well managed within the phone. Possible modification or injection still exists on OS level.

\subsection{Zero Knowledge Contingent Payments in Red Belly Blockchain}
\label{sec:zkcp_discussion}

The Zero Knowledge Contingent Payments model in Red Belly Blockchain is rather a model or future work to go. The implementation of it is based on common safety assumptions of well-known techniques mentioned in Section \ref{sec:zkcp_preliminaries}. Hence, the proof is well addressed under real life applications. In addition to this, because of the lack of scripts in Red Belly Blockchain, we have to adopt the \textit{cut-and-choose} technique which requires a lot of redundancies. The time complexity of it can be simply conclude as $O(tn)$ where we apply \textit{cut-and-choose} twice.


\section{Future Work}

\subsection{Secure Wallet}

Obviously more tests involving more \textit{participants} should be carried on in order to benchmark the performance and find out the bottleneck so that a better solution can be derived to make the wallet easy to use. 

In addition to this, a measure on the performance when coming to large size of UTXOs is needed. Both the lag of network and the time to traverse the whole UTXOs are required to be analyzed. Tests on possible defects on storage can be carried as well. 

\subsection{ZKCP model of RBBC}

As the discussion in Section \ref{sec:zkcp_discussion}, the ZKCP model requires further proof as well as improvements in efficiency. Also a timing mechanism is n eeded if we will integrate the ZKCP model into Red Belly Blockchain as it uses the \textit{time-locked commitment}.

\section{Conclusion}

In conclusion, the risks behind current cryptocurrencies technology motivates this research to explore a way to ensure security in both blockchain levels and contracts levels, referring to the development of secure wallet and the design of zero knowledge contingent payments respectively in our case. By the help of Red Belly Blockchain with Democratic Byzantine Consensus System running, the first version of secure wallet provides a satisfying performance under basic tests. The ZKCP model also shows a potential to secure transaction with less support from system-level compared to Bitcoin Scripts or Ethereum's Smart Contracts. Although there is no build or benchmarks at current stage, the capability to involve a mechanism ensuring no parties can cheat within a transaction is of vital importance considering the security issue that we emphasize most in this research.

The application or future of this research can goes into a wider range not limited to a secure wallet on Android or a draft model of the \textit{zero knowledge contingent payments}. Further research can be conducted in order to find out the better usage or improvements for a secure blockchain as our pursuit.



\newpage
\bibliography{bibliography.bib}
\bibliographystyle{plain}

\end{document}
